#!/bin/dash

# Initialises variables used in this script
. gitlite-conf
# Checks if the repo exists
. gitlite-exists

# Getting the target branch
targetBranch="$1"
shift

message=""
while test $# -gt 0; do  # $# is the number of args
    case "$1" in
        -m)
            # Extracting the commit message
            shift
            message=$1
            shift
            ;;
        *)
            exit 1
            ;;
    esac
done
if test -z "$message"; then
    echo "$thisFile: error: empty commit message"
    exit 1
fi

branchTipDir="$repoName/$targetBranch/"

# Can't merge a non-existent branch
if ! test -e $branchTipDir; then
    echo "$thisFile: error: unknown branch '$targetBranch'"
    exit 1
fi

# Check if this is a fast-forward merge
isFastForward=false

baseDir="$repoName/.${targetBranch}-base"
currBranchDir="$repoName/$currBranch"

# Check if the base is identical to the current branch. If it is,
# this indicates the current branch never diverged
if gitlite-directory-diff "$baseDir" "$currBranchDir" > /dev/null; then
    # Fast forward merging!
    # Remove all files in CWD, index and current branch
    rm $(ls) 2> /dev/null
    cd $stageDir
    rm $(ls) 2> /dev/null
    cd ../$currBranch
    rm $(ls) 2> /dev/null
    cd ../..
    # Copy over every file in the target branch tip to CWD, index and current branch
    for eachFile in $(ls $branchTipDir); do
        cp "$branchTipDir/$eachFile" "$eachFile"
        cp "$branchTipDir/$eachFile" "$stageDir/$eachFile"
        cp "$branchTipDir/$eachFile" "$repoName/$currBranch/$eachFile"
    done

    # Update the log file of current branch
    cp "$branchTipDir/.log" "$logFile"
    echo "Fast-forward: no commit created"
else
    # Attempting to auto-merge
    isConflict=false

    baseDir="$repoName/.${targetBranch}-base"
    currBranchDir="$repoName/$currBranch"
    targetBranchDir="$repoName/$targetBranch"
    # Form a set of the files present in the 3 directories: base, cwd and target branch
    fileSet=$(ls $currBranchDir $baseDir $targetBranchDir | tr " " "\n" | sort | uniq | tr "\n" " ")
    
    for eachFile in $fileSet; do
        currFile="$currBranchDir/$eachFile"
        baseFile="$baseDir/$eachFile"
        baseFileCopy="${eachFile}-base"
        cp "$baseFile" "$baseFileCopy" 2> /dev/null
        targetFile="$targetBranchDir/$eachFile"
        # Use a copy of the base file as a merging dryrun
        diff -u "$baseFileCopy" "$currFile" > .patch.1 2> /dev/null
        diff -u "$baseFileCopy" "$targetFile" > .patch.2 2> /dev/null
        patch --merge < .patch.1 > /dev/null
        if ! patch --merge --dry-run < .patch.2 > /dev/null; then
            if test $isConflict = "false"; then
                isConflict=true
                echo "$thisFile: error: These files can not be merged:"
            fi
            echo "$eachFile"
        fi
        rm "${eachFile}.orig" "$baseFileCopy" ".patch.1" ".patch.2" 2> /dev/null
    done;
    if test "$isConflict" = "true"; then
        exit 1
    fi

    # No conflicts. Proceeding with auto-merges
    for eachFile in $fileSet; do
        currFile="$currBranchDir/$eachFile"
        baseFile="$baseDir/$eachFile"
        baseFileCopy=".${eachFile}-base.copy"
        cp "$baseFile" "$baseFileCopy" 2> /dev/null
        targetFile="$targetBranchDir/$eachFile"

        if test -e "$currFile" && test -e "$targetFile"; then
            if ! (test -z "$(diff $currFile $targetFile)" || test -z "$(diff $currFile $baseFile)"); then
                echo "Auto-merging $eachFile"
            fi
            diff -u "$baseFileCopy" "$currFile" > .patch.1 2> /dev/null
            diff -u "$baseFileCopy" "$targetFile" > .patch.2 2> /dev/null
            patch --merge < .patch.1 > /dev/null
            patch --merge < .patch.2 > /dev/null
            cp "$baseFileCopy" "$currFile" 2> /dev/null
            rm "$baseFileCopy" 2> /dev/null
            gitlite-add $eachFile
            rm "${eachFile}.orig" ".patch.1" ".patch.2" 2> /dev/null
        elif test -e "$targetFile"; then
            cp "$targetFile" "$eachFile"
            gitlite-add $eachFile
        fi

        
    done;
    gitlite-commit -m "$message"

    # Merging the log files from the two branches
    # Using tmp file to workaround a concurrency bug(?)... :(
    cat "$logFile" "$repoName/$targetBranch/.log" | sort -r | uniq > tmp
    cp tmp "$logFile"
    rm tmp
fi
