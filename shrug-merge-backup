#!/bin/dash

. shrug-conf
. shrug-exists

# Getting the target branch
targetBranch="$1"
shift

message=""
while test $# -gt 0; do  # $# is the number of args
    case "$1" in
        -m)
            # Extracting the commit message
            shift
            message=$1
            shift
            ;;
        *)
            exit 1
            ;;
    esac
done
if test -z "$message"; then
    echo "$thisFile: error: empty commit message"
    exit 1
fi

branchTipDir="$repoName/$targetBranch/"

# Can't merge a non-existent branch
if ! test -e $branchTipDir; then
    echo "$thisFile: error: unknown branch '$targetBranch'"
    exit 1
fi

# Check if this is a fast-forward merge
baseDir="$repoName/.${targetBranch}-base"
currBranchDir="$repoName/$currBranch"


if test -z $(diff -r "$baseDir" "$currBranchDir" | egrep -v "[.]log"); then
    # This is a fast forward merge.
    # Remove all files in CWD, index and current branch
    rm $(ls) 2> /dev/null
    cd $stageDir
    rm $(ls) 2> /dev/null
    cd ../$currBranch
    rm $(ls) 2> /dev/null
    cd ../..

    # Copy over every file in the target branch tip to CWD, index and current branch
    for eachFile in $(ls $branchTipDir); do
        cp "$branchTipDir/$eachFile" "$eachFile"
        cp "$branchTipDir/$eachFile" "$stageDir/$eachFile"
        cp "$branchTipDir/$eachFile" "$repoName/$currBranch/$eachFile"
    done

    # Update the log file of current branch
    cp "$branchTipDir/.log" "$logFile"

    echo "Fast-forward: no commit created"
else
    # Attempting to auto-merge
    isConflict=false

    baseDir="$repoName/.${targetBranch}-base"
    currBranchDir="$repoName/$currBranch"
    targetBranchDir="$repoName/$targetBranch"
    baseFiles="$(ls $baseDir)"
    currBranchFiles=$(ls $currBranchDir)
    targetBranchFiles=$(ls $targetBranchDir)

    # echo "===== Curr Branch Files    ====="
    # echo $(ls $currBranchDir)
    # echo "===== Base Files           ====="
    # echo $(ls $baseDir)
    # echo "===== Target Branch Files  ====="
    # echo $(ls $targetBranchDir)

    fileSet=$(echo $currBranchFiles $baseFiles $targetBranchFiles | tr " " "\n" | sort | uniq | tr "\n" " ")
    for eachFile in $fileSet; do
        currFile="$currBranchDir/$eachFile"
        baseFile="$baseDir/$eachFile"
        baseFileCopy="${eachFile}-base"
        cp "$baseFile" "$baseFileCopy" 2> /dev/null
        targetFile="$targetBranchDir/$eachFile"

        # echo "=== Base ==="
        # cat "$baseFileCopy"
        # echo "=== Curr ==="
        # cat "$currFile"
        # echo "=== Targ ==="
        # cat "$targetFile"

        diff -u "$baseFileCopy" "$currFile" > .patch.1 2> /dev/null
        diff -u "$baseFileCopy" "$targetFile" > .patch.2 2> /dev/null
        patch --merge < .patch.1 > /dev/null
        if ! patch --merge --dry-run < .patch.2 > /dev/null; then
            if test $isConflict = "false"; then
                isConflict=true
                echo "$thisFile: error: These files can not be merged:"
            fi
            echo "$eachFile"
        fi
        rm "${eachFile}.orig" "$baseFileCopy" ".patch.1" ".patch.2" 2> /dev/null
    done;
    if test "$isConflict" = "true"; then
        exit 1
    fi

    # No conflicts. Proceeding with auto-merges
    for eachFile in $fileSet; do
        currFile="$currBranchDir/$eachFile"
        baseFile="$baseDir/$eachFile"
        baseFileCopy=".${eachFile}-base.copy"
        cp "$baseFile" "$baseFileCopy" 2> /dev/null
        targetFile="$targetBranchDir/$eachFile"

        # echo "=== Base ==="
        # cat "$baseFileCopy"
        # echo "=== Curr ==="
        # cat "$currFile"
        # echo "=== Targ ==="
        # cat "$targetFile"

        if test -e "$currFile" && test -e "$targetFile"; then
            diff -u "$baseFileCopy" "$currFile" > .patch.1 2> /dev/null
            diff -u "$baseFileCopy" "$targetFile" > .patch.2 2> /dev/null
            patch --merge < .patch.1 > /dev/null
            patch --merge < .patch.2 > /dev/null
            cp "$baseFileCopy" "$currFile" 2> /dev/null
            rm "$baseFileCopy" 2> /dev/null
            echo "Auto-merging $eachFile"
            shrug-add $eachFile
            rm "${eachFile}.orig" ".patch.1" ".patch.2" 2> /dev/null
        elif test -e "$targetFile"; then
            cp "$targetFile" "$eachFile"
            shrug-add $eachFile
        fi

        
    done;
    shrug-commit -m "$message"

    # Merging the log files from the two branches
    # Using tmp file to workaround a concurrency bug(?)... ;(
    cat "$logFile" "$repoName/$targetBranch/.log" | sort -r | uniq > tmp
    cp tmp "$logFile"
    rm tmp
fi


